# C_Basic
C언어 기본 학습 리포지토리

# Day1

## c언어

### c언어의 특징
- 절차지향 프로그래밍 언어
- 빠르고 효율적인 저수준(low-level) 프로그래밍 언어
	- 메모리 주소를 직접 지정할 수 있음(포인터 활용)
	- 하드웨어 친화적
- 메모리 주소를 직접 다룰 수 있는 포인터를 기능을 제공
	- 배열과 문자열 처리에 용이
	- 효율적인 데이터 구조를 만들 수 있음(연결 리스트, 트리 등등)


### 자료형
- 자료형은 변수에 저장되는 데이터의 형식을 말함
- 자료형은 크게 기본형과 파생형으로 나뉨
- 기본형은 정수형, 실수형, 문자형, 논리형이 있음
- 파생형은 배열, 포인터, 구조체, 공용체, 열거형이 있음

- 정수형 : int, short, long, long long
	- 정수형은 음수, 양수, 0을 저장할 수 있음
		- int : 4바이트 (32비트) * 컴파일러에 따라 다름
		- short : 2바이트 (16비트)
		- long : 4바이트 (32비트)
		- long long : 8바이트 (64비트)
- 실수형 : float, double, long double
	- 실수형은 소수점을 가진 수를 저장할 수 있음
		- float : 4바이트 (32비트)
		- double : 8바이트 (64비트)
- 문자형 : char
	- 문자형은 문자를 저장할 수 있음
		- char : 1바이트 (8비트)
- 논리형 : bool
	- 논리형은 참과 거짓을 저장할 수 있음
		- bool : 1바이트 (8비트)




- 함수 정의 , 함수 호출(출력이없고, 중괄호가있는것), 함수 선언
- 파이썬은 들여쓰기 C언어는 중괄호로 구분
- def function(): <- 파이썬
- void function(){} <- C언어
- 함수 선언은 함수의 원형을 미리 선언하는것
- 함수의 원형을 선언하면 함수의 위치에 상관없이 사용가능
- 함수의 원형을 선언하지 않으면 함수의 위치가 중요해짐
- 함수의 원형을 선언할때는 함수의 이름과 반환형, 매개변수를 적어줌



### 형식 지정자 

- 형식 지정자는 출력할 데이터의 형식을 지정하는데 사용

- 형식지정자 종류

| 형식 지정자 | 설명 |
|------------|------|
| `%d` 또는 `%i` | 10진수 정수 출력 |
| `%x` / `%X` | 16진수 정수 출력 (소문자/대문자) |
| `%o` | 8진수 정수 출력 |
| `%c` | 문자 출력 |
| `%s` | 문자열 출력 |
| `%f` | 실수 출력 (소수점 이하 6자리) |
| `%e` / `%E` | 지수 표기법 출력 |
| `%g` / `%G` | 자동 변환 (`%f` 또는 `%e`) |
| `%p` | 포인터 주소 출력 (C 전용) |



### 변수
- 변수는 데이터를 저장하는 공간
- 변수는 메모리에 저장됨
- 변수는 크기와 형식을 가짐(정수, 실수, 문자 등)

	- 변수 선언시
	```
	#include <stdio.h>

	int main()
	{
		int num;		// 자료형 변수명
		num = 10;

		int num2 = 20;	// 변수 선언과 동시에 초기화

		printf("%d\n", num);
		printf("%d\n", num2);

		return 0;
	}
	```

### 메모리

ROM : Read Only Memory (읽기 전용 메모리)
RAM : Random Access Memory (임의 접근 메모리)
- 프로그램이 실행되면 ROM에 있는 프로그램이 RAM으로 옮겨짐
- RAM은 전원이 꺼지면 데이터가 사라짐
- 함수가 호출되면 스택에 저장되고 함수가 끝나면 스택에서 제거됨
	- 지역변수 : `함수`가 호출될때 생성되고 함수가 끝나면 제거됨
	- 전역변수 : `프로그램`이 실행될때 생성되고 프로그램이 끝나면 제거됨

### 레지스터

- CPU 내부에 있는 메모리
- CPU가 계산을 할때 사용하는 메모리
- 레지스터에 있는 데이터를 RAM으로 옮겨서 계산을 하고 다시 레지스터로 옮김
- 레지스터는 속도가 빠르기 때문에 계산을 할때 사용함
- 레지스터는 매우 적은 양의 데이터만 저장할 수 있음
- 레지스터는 전원이 꺼지면 데이터가 사라짐




# Day2

## 연산자 정리

### 🔹 1. 산술 연산자 (Arithmetic Operators)

| 연산자 | 설명 | 예제 (`a = 10, b = 3`) | 결과 |
|--------|-----|-------------------|------|
| `+` | 덧셈 | `a + b` | `13` |
| `-` | 뺄셈 | `a - b` | `7` |
| `*` | 곱셈 | `a * b` | `30` |
| `/` | 나눗셈 | `a / b` | `3` (정수 나눗셈) |
| `%` | 나머지 연산 | `a % b` | `1` |

### 🔹 2. 대입 연산자 (Assignment Operators)

| 연산자 | 설명 | 예제 (`a = 10`) | 결과 (`a`) |
|--------|-----|------------|------|
| `=` | 대입 | `a = 5` | `5` |
| `+=` | 더해서 대입 | `a += 3` | `13` |
| `-=` | 빼서 대입 | `a -= 3` | `7` |
| `*=` | 곱해서 대입 | `a *= 3` | `30` |
| `/=` | 나눠서 대입 | `a /= 3` | `3` |
| `%=` | 나머지 대입 | `a %= 3` | `1` |

### 🔹 3. 비교 연산자 (Comparison Operators)

| 연산자 | 설명 | 예제 (`a = 10, b = 3`) | 결과 |
|--------|-----|--------------|------|
| `==` | 같음 | `a == b` | `0` (false) |
| `!=` | 다름 | `a != b` | `1` (true) |
| `>` | 초과 | `a > b` | `1` |
| `<` | 미만 | `a < b` | `0` |
| `>=` | 이상 | `a >= b` | `1` |
| `<=` | 이하 | `a <= b` | `0` |

### 🔹 4. 논리 연산자 (Logical Operators)

| 연산자 | 설명 | 예제 (`a = 1, b = 0`) | 결과 |
|--------|-----|------------------|------|
| `&&` | AND (둘 다 참이면 참) | `a && b` | `0` (false) |
| `||` | OR (둘 중 하나라도 참이면 참) | `a || b` | `1` (true) |
| `!` | NOT (반대값 반환) | `!a` | `0` (false) |

### 🔹 5. 비트 연산자 (Bitwise Operators)

| 연산자 | 설명 | 예제 (`a = 5, b = 3`) | 결과 (`a=5(101), b=3(011)`) |
|--------|-----|--------------|------|
| `&` | AND | `a & b` | `1` (001) |
| `|` | OR | `a | b` | `7` (111) |
| `^` | XOR | `a ^ b` | `6` (110) |
| `~` | NOT | `~a` | `-6` (2의 보수) |
| `<<` | 왼쪽 시프트 | `a << 1` | `10` (1010) |
| `>>` | 오른쪽 시프트 | `a >> 1` | `2` (10) |

### 🔹 6. 증감 연산자 (Increment & Decrement Operators)

| 연산자 | 설명 | 예제 (`a = 5`) | 결과 |
|--------|-----|------------|------|
| `++a` | 전위 증가 | `b = ++a;` | `a=6, b=6` |
| `a++` | 후위 증가 | `b = a++;` | `a=6, b=5` |
| `--a` | 전위 감소 | `b = --a;` | `a=4, b=4` |
| `a--` | 후위 감소 | `b = a--;` | `a=4, b=5` |

### 🔹 7. 삼항 연산자 (Ternary Operator)

```c
int a = 10, b = 5;
int min = (a < b) ? a : b;  // a가 b보다 작으면 a, 아니면 b
printf("Min: %d", min);  // 출력: Min: 5
```

### 🔹 8. 형 변환 연산자 (Type Casting Operators)

```c
double result = (double)10 / 3;  // 정수를 실수로 변환
printf("%.2f", result);  // 출력: 3.33
```


## 제어문

1. 선택제어문 : if문, switch문

	- if문 형식
	```
	if(조건식)
	{
		실행문;
	}
	else if(조건식)
	{
		실행문;
	}
	else
	{
		실행문;
	}
	```
	- switch문 형식
	```
	switch(변수)
	{
		case 값1:
			실행문;
			break;
		case 값2:
			실행문;
			break;
		default:
			실행문;
			break;
	}
	```
2. 반복제어문 : for문, while문, do-while문

	- for문 형식
	```
	for(초기식; 조건식; 증감식)
	{
		실행문;
	}
	```
	- while문 형식
	```
	while(조건식)
	{
		실행문;
	}
	```
	- do-while문 형식
	```
	do
	{
		실행문;
	}
	while(조건식);
	```

	## 🔹 `for` 문 vs `while` 문 비교 정리  

| 비교 항목        | `for` 문                                  | `while` 문                               |
|-----------------|---------------------------------|---------------------------------|
| **반복 횟수**   | 정해진 횟수만큼 반복 (`range`, 리스트 등) | 특정 조건을 만족할 때까지 반복 |
| **사용 목적**   | 리스트, 튜플, 문자열 등 시퀀스 순회 | 조건이 `False`가 될 때까지 실행 |
| **종료 조건**   | 반복 횟수를 다 채우면 자동 종료 | 조건이 `False`가 되거나 `break` 사용 |
| **적용 예시**   | 리스트 요소 출력, 고정된 횟수 반복 | 무한 루프, 사용자 입력 처리 |
| **무한 루프**   | `for` 문 자체로는 발생 X (`range` 한정) | 조건이 항상 `True`이면 무한 루프 |
| **사용 예제**   | ```python\nfor i in range(5): print(i)``` | ```python\nwhile x < 5: print(x); x += 1``` |

### 한마디로 정리하면?  
- **반복 횟수가 정해져 있으면** `for`  
- **조건이 충족될 때까지 반복해야 하면** `while

# Day 03 

## 포인터 심화 학습

날짜: 2025-03-13  
깃허브 링크: [day03 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day03)

---

### 학습 주제
- 포인터와 배열의 관계
- `*`와 `&` 연산자의 정확한 의미와 사용법
- 포인터 주소값과 자료형에 따른 크기 차이
- `scanf_s` 사용 시 `sizeof`가 필요한 이유

---

### 포인터와 배열

- 배열 이름은 포인터 상수처럼 동작한다.  
  예시: `int arr[5];`  
  `arr`은 `&arr[0]`과 동일한 메모리 주소를 가리킨다.
- 포인터를 이용해서 배열의 요소에 접근할 수 있다.

```c
int arr[3] = {10, 20, 30};
int *p = arr;   // p는 arr[0]의 주소를 가짐

printf("%d\n", *p);        // 10 (arr[0])
printf("%d\n", *(p + 1));  // 20 (arr[1])
printf("%d\n", *(p + 2));  // 30 (arr[2])
```

- 배열과 포인터는 비슷해 보이지만 엄연히 다르다.  
  포인터는 변수로 값을 변경할 수 있지만, 배열 이름은 주소값이 상수라 변경할 수 없다.

---

### `*`와 `&`의 정확한 의미

| 기호  | 의미                         | 사용 예시          |
| ----- | ---------------------------- | ------------------ |
| `*`   | 역참조 연산자 (Dereference). 포인터가 가리키는 값을 가져온다 | `*ptr = 100;` → 포인터가 가리키는 주소에 100 저장 |
| `&`   | 주소 연산자. 변수의 메모리 주소값을 가져온다 | `ptr = &a;` → 변수 a의 주소를 ptr에 저장 |

#### 예제
```c
int a = 10;
int *ptr = &a;

printf("%p\n", ptr);  // ptr이 가리키는 주소값 출력
printf("%d\n", *ptr); // ptr이 가리키는 주소에 저장된 값 출력 (10)
```

---

### 포인터와 자료형 크기, 메모리 크기 차이

- 포인터 변수는 자료형에 상관없이 주소값을 저장한다.
- 포인터가 저장하는 주소의 크기는 시스템 아키텍처에 따라 다르다.
  - 32비트 시스템 → 4바이트
  - 64비트 시스템 → 8바이트

```c
int *p1;
char *p2;
double *p3;

printf("%d\n", sizeof(p1)); // 8 (64비트 기준)
printf("%d\n", sizeof(p2)); // 8
printf("%d\n", sizeof(p3)); // 8
```

### 주의할 점
- 포인터가 가리키는 대상(자료형)은 크기와 관계없다.  
  포인터는 "주소값"만 저장한다.
- 하지만 역참조(`*ptr`)할 때는 자료형 크기에 맞게 값을 가져오고 처리한다.  
  예시:
  - `int *` → 4바이트 데이터
  - `char *` → 1바이트 데이터

---

## `scanf_s`와 `sizeof`가 필요한 이유

- `scanf_s`는 입력 버퍼의 크기를 명시적으로 요구한다.  
  버퍼 오버플로 방지 목적이며, 특히 문자열 입력에서 보안 강화를 위해 도입되었다.

### 문자열 입력 시 `scanf_s`
```c
char str[10];
scanf_s("%s", str, (unsigned)_countof(str)); // 또는 sizeof(str)
```

- `scanf`와 달리 `scanf_s`는 문자열(char 배열) 입력을 받을 때,  
  버퍼 크기(최대 입력 길이)를 추가로 전달해야 한다.
- 숫자(int, float 등)는 추가 인자가 필요 없다.  
  포인터가 직접 값을 가리키고 있기 때문이다.

### 왜 문자열만?
- 문자열(`%s`)은 포인터를 통해 문자열 전체를 다룬다.  
  어디까지가 안전한지 판단할 기준(배열 크기)을 제공해야 한다.
- 포인터의 주소만 주면 크기를 알 수 없기 때문에, 명시적으로 크기를 넘겨줘야 안전하게 동작한다.

---

### 정리 요약

- 포인터는 주소값을 저장하며, `*`와 `&` 연산자를 통해 값을 참조하고 주소를 얻는다.
- 배열과 포인터는 비슷하지만, 배열 이름은 상수 포인터이고 변경할 수 없다.
- 포인터의 크기는 시스템에 따라 4바이트 또는 8바이트이고, 자료형 크기와는 무관하다.
- `scanf_s`는 문자열 입력 시 반드시 버퍼 크기를 넘겨야 하며, 버퍼 오버플로를 방지하기 위한 기능이다.

---


# day04

## 동적 할당
