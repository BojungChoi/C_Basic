# C_Basic
C 언어 기본 학습 리포지토리

---

# Day 01 - C 언어 기초
날짜: 2025-03-11  
깃허브 링크: [day01 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day01)

---

### 학습 주제
- C 언어의 특징
- 자료형과 변수
- 함수 개념 및 선언/정의/호출
- 형식 지정자
- 메모리 구조 (ROM, RAM, 레지스터)

---

### C 언어의 특징
- 절차지향 프로그래밍 언어
- 빠르고 효율적인 저수준(low-level) 언어
  - 메모리 주소를 직접 지정할 수 있음 (포인터 활용)
  - 하드웨어 친화적
- 포인터 기능 제공
  - 배열과 문자열 처리에 용이
  - 효율적인 데이터 구조를 구현 가능 (연결 리스트, 트리 등)

---

### 자료형

#### 기본형
| 자료형 | 크기 | 설명 |
|--------|------|------|
| `char` | 1바이트 (8비트) | 문자 |
| `int` | 4바이트 (32비트) | 정수 |
| `short` | 2바이트 (16비트) | 작은 정수 |
| `long` | 4바이트 (32비트) | 큰 정수 |
| `long long` | 8바이트 (64비트) | 더 큰 정수 |
| `float` | 4바이트 | 실수 (소수점) |
| `double` | 8바이트 | 정밀한 실수 |

#### 파생형
- 배열, 포인터, 구조체, 공용체, 열거형 등이 있음

---

### 함수
- 함수 선언: 함수 원형을 미리 선언해서 호출 순서와 무관하게 사용 가능
- 함수 정의: 함수의 실제 구현부
- 함수 호출: 정의된 함수 실행

#### 예시
```c
void function(); // 선언

void function() { // 정의
  printf("Hello\n");
}

int main() {
  function(); // 호출
  return 0;
}
```

---

### 형식 지정자

| 형식 지정자 | 설명 |
|-------------|------|
| `%d` / `%i` | 10진수 정수 출력 |
| `%x` / `%X` | 16진수 정수 출력 |
| `%o` | 8진수 정수 출력 |
| `%c` | 문자 출력 |
| `%s` | 문자열 출력 |
| `%f` | 실수 출력 (소수점 이하 6자리) |
| `%e` / `%E` | 지수 표기법 출력 |
| `%g` / `%G` | 자동 변환 (`%f` 또는 `%e`) |
| `%p` | 포인터 주소 출력 |

---

### 메모리 구조

| 메모리 | 설명 |
|--------|------|
| ROM | 읽기 전용 메모리. 프로그램이 저장되어 있음 |
| RAM | 임의 접근 메모리. 프로그램 실행 시 데이터 저장 |
| 레지스터 | CPU 내부 메모리. 계산 시 데이터 임시 저장 공간 |

#### 지역변수와 전역변수
- 지역변수: 함수가 호출될 때 생성, 종료 시 소멸
- 전역변수: 프로그램 시작 시 생성, 종료 시 소멸

---

# Day 02 - 연산자 & 제어문
날짜: 2025-03-12  
깃허브 링크: [day02 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day02)

---

### 연산자 정리

#### 산술 연산자
| 연산자 | 설명 | 예제 (`a = 10, b = 3`) | 결과 |
|--------|------|-------------------|------|
| `+` | 덧셈 | `a + b` | `13` |
| `-` | 뺄셈 | `a - b` | `7` |
| `*` | 곱셈 | `a * b` | `30` |
| `/` | 나눗셈 | `a / b` | `3` (정수 나눗셈) |
| `%` | 나머지 | `a % b` | `1` |

#### 논리 연산자
| 연산자 | 설명 | 예제 (`a = 1, b = 0`) | 결과 |
|--------|------|------------------|------|
| `&&` | AND | `a && b` | `0` |
| `∥` | OR | `a∥b` | `1` |
| `!` | NOT | `!a` | `0` |

---

### 제어문

#### 조건문
```c
if (조건) {
  실행문;
} else if (조건) {
  실행문;
} else {
  실행문;
}
```

#### 반복문
```c
for (초기식; 조건식; 증감식) {
  실행문;
}

while (조건식) {
  실행문;
}

do {
  실행문;
} while (조건식);
```

---

# Day 03 - 포인터 심화 학습

날짜: 2025-03-13  
깃허브 링크: [day03 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day03)

---

### 학습 주제
- 포인터와 배열의 관계
- `*`와 `&` 연산자의 정확한 의미와 사용법
- 포인터 주소값과 자료형에 따른 크기 차이
- `scanf_s` 사용 시 `sizeof`가 필요한 이유

---

### 포인터와 배열
- 배열 이름은 포인터 상수처럼 동작  
  예시: `int arr[5];`  
  `arr`은 `&arr[0]`과 동일한 메모리 주소를 가리킨다.

```c
int arr[3] = {10, 20, 30};
int *p = arr;

printf("%d\n", *p);        // 10
printf("%d\n", *(p + 1));  // 20
printf("%d\n", *(p + 2));  // 30
```

---

### `*`와 `&`의 정확한 의미

| 기호 | 의미 | 예제 |
|------|------|------|
| `*` | 역참조 (포인터가 가리키는 값 접근) | `*ptr = 100;` |
| `&` | 주소값 취득 | `ptr = &a;` |

```c
int a = 10;
int *ptr = &a;

printf("%p\n", ptr);  // 주소 출력
printf("%d\n", *ptr); // 값 출력
```

---

### 포인터 주소값과 자료형 크기

- 포인터는 자료형에 상관없이 주소값만 저장  
- 크기는 시스템 아키텍처 기준  
  - 32비트 시스템: 4바이트  
  - 64비트 시스템: 8바이트

```c
int *p1;
char *p2;
double *p3;

printf("%d\n", sizeof(p1)); // 8 (64비트)
printf("%d\n", sizeof(p2)); // 8
printf("%d\n", sizeof(p3)); // 8
```

#### 주의
- 역참조(`*ptr`)할 때 자료형 크기에 맞게 처리됨  
  `int *`는 4바이트, `char *`는 1바이트

---

### `scanf_s`와 `sizeof`가 필요한 이유

- `scanf_s`는 버퍼 오버플로 방지 목적  
- 문자열 입력 시 반드시 버퍼 크기 명시 필요

```c
char str[10];
scanf_s("%s", str, (unsigned)_countof(str)); // 또는 sizeof(str)
```

#### 왜 문자열만?  
- 문자열(`%s`)은 포인터만 전달 → 크기를 알 수 없음  
- 명시적으로 버퍼 크기를 넘겨줘야 안전

---

### 정리 요약
- 포인터는 주소값 저장, `*`와 `&`로 값과 주소를 다룸  
- 배열과 포인터는 유사하지만 다르며, 배열 이름은 상수 포인터  
- 포인터 크기는 시스템 기준으로 고정  
- `scanf_s`는 문자열 입력 시 추가 인자 필요 (버퍼 크기)

---

## Day 04 - 배열과 포인터


날짜: 2025-03-14  
깃허브 링크: [day04 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day04)

---


## `getchar()` 함수
- **키보드로부터 한 문자 입력을 받는 함수**.
- 입력한 **한 문자를 그대로 반환**한다.
- 버퍼에 남아있는 문자도 순차적으로 읽을 수 있다.
- `Enter`를 입력해야 함수가 동작한다 (입력이 완료됨을 의미).

### 기본 사용법
```c
#include <stdio.h>

int main() {
    char ch;
    
    printf("문자를 입력하세요: ");
    ch = getchar();  // 사용자 입력 한 글자 읽기
    
    printf("입력한 문자: %c\n", ch);
    
    return 0;
}
```

### 여러 문자 연속 입력 (반복문 사용)
```c
#include <stdio.h>

int main() {
    char ch;

    printf("여러 문자를 입력하고 Enter를 누르세요: \n");

    while ((ch = getchar()) != '\n') {
        printf("입력한 문자: %c\n", ch);
    }

    printf("입력이 끝났습니다.\n");

    return 0;
}
```

---
## `putchar()` 함수
- 문자 **한 개를 출력**하는 함수.
- 괄호 안에 **문자 리터럴**이나 **문자 변수**를 넣어서 출력할 수 있음.
- 반환값은 출력한 문자를 그대로 반환한다.

### 기본 사용법
```c
#include <stdio.h>

int main() {
    char ch = 'A';
    
    putchar(ch);   // A 출력
    putchar('\n'); // 줄바꿈

    return 0;
}
```

### 반복문으로 문자 여러 개 출력
```c
#include <stdio.h>

int main() {
    char str[] = "Hello";
    int i = 0;
    
    while (str[i] != '\0') {
        putchar(str[i]);
        i++;
    }

    putchar('\n');

    return 0;
}
```

## `getchar()` + `putchar()` 콜라보 예제
```c
#include <stdio.h>

int main() {
    char ch;

    printf("문자를 입력하고 Enter를 누르세요: \n");

    while ((ch = getchar()) != '\n') {
        putchar(ch);  // 입력한 문자 그대로 출력
    }

    putchar('\n');
    
    return 0;
}
```

---


###  배열 (Array)
- 같은 타입의 여러 데이터를 하나의 변수 이름으로 관리하는 자료구조.
- 인덱스를 통해 각 요소에 접근 가능 (`0`부터 시작).

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    printf("첫 번째 값: %d\n", arr[0]);
    printf("세 번째 값: %d\n", arr[2]);
    
    return 0;
}
```

---

### `static` 변수
- 함수 내에서 선언되면, **한 번만 초기화**되고 프로그램이 끝날 때까지 유지됨.
- 전역 변수처럼 메모리에 유지되지만, **블록 스코프를 가짐**.

```c
#include <stdio.h>

void counter() {
    static int count = 0;  // static 변수
    count++;
    printf("count: %d\n", count);
}

int main() {
    counter();  // count: 1
    counter();  // count: 2
    counter();  // count: 3
    
    return 0;
}
```

---

### `strcmp()` 함수
- 문자열을 비교하는 함수 (`string compare`).
- `<string.h>` 라이브러리에 포함.
- 반환값:
  - `0` : 두 문자열이 같음
  - 양수(1) : 첫 번째 문자열이 사전순으로 더 큼
  - 음수(-1) : 첫 번째 문자열이 사전순으로 더 작음

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "apple";
    char str2[] = "banana";
    
    int result = strcmp(str1, str2);
    
    if (result == 0) {
        printf("두 문자열이 같습니다.\n");
    } else if (result < 0) {
        printf("str1이 str2보다 사전순으로 앞섭니다.\n");
    } else {
        printf("str1이 str2보다 사전순으로 뒤섭니다.\n");
    }
    
    return 0;
}
```

---

### 문자열 (String)
- `char` 배열로 표현.
- 문자열 끝에는 `\0`이 자동으로 들어감 (널 문자).

```c
#include <stdio.h>

int main() {
    char str[10] = "Hello";
    
    printf("문자열 출력: %s\n", str);
    printf("첫 번째 문자: %c\n", str[0]);
    
    return 0;
}
```

---

### 값 전달 (Value)
- 함수 호출 시 인자로 **값을 복사해서 전달**.
- 원본 값은 변하지 않음.

```c
#include <stdio.h>

void changeValue(int x) {
    x = 100;
}

int main() {
    int num = 50;
    
    changeValue(num);
    printf("num 값: %d\n", num);  // 50 (원본 값은 변화 없음)
    
    return 0;
}
```

---

### 포인터 변수 (Pointer Variable)
- **주소값**을 저장하는 변수.
- `*`와 `&` 기호를 사용.
- `*` : 포인터가 가리키는 값
- `&` : 변수의 주소값

```c
#include <stdio.h>

int main() {
    int num = 10;
    int *ptr = &num;  // num의 주소 저장
    
    printf("num의 주소값: %p\n", &num);
    printf("ptr이 가리키는 주소값: %p\n", ptr);
    printf("ptr이 가리키는 값: %d\n", *ptr);
    
    *ptr = 20;  // 포인터를 통해 값 변경
    printf("num의 값: %d\n", num);
    
    return 0;
}
```

---

### 포인터를 이용한 값 전달
- 포인터를 인자로 넘기면, **원본 값 수정 가능**.

```c
#include <stdio.h>

void changeValue(int *x) {
    *x = 100;
}

int main() {
    int num = 50;
    
    changeValue(&num);
    printf("num 값: %d\n", num);  // 100 (원본 값이 변경됨)
    
    return 0;
}
```

---

###  요약
| 개념         | 설명                                                  |
|--------------|-------------------------------------------------------|
| 배열(Array)  | 같은 타입의 데이터를 순차적으로 저장하는 자료구조     |
| static 변수  | 함수가 끝나도 값이 유지되는 지역 변수                 |
| strcmp()     | 문자열 비교 함수, 같으면 0 반환                       |
| 문자열(String) | `char` 배열로 구현, `\0`으로 끝남                  |
| 값 전달      | 함수에 값을 복사해서 넘김, 원본은 변경 안됨          |
| 포인터       | 변수의 주소를 저장하는 변수, 원본 값 변경 가능        |

---

## 코드 세그먼트, 데이터 세그먼트, 힙, 스택

- 데이터 세그먼트 : 전역변수와 정적변수가 저장되는 메모리 영역
	- 힙 : 사용자에게 의해 동적으로 할당되는 메모리 영역
	- 스택 : 함수 호출 시 생성되는 지역변수와 매개변수가 저장되는 메모리 영역
	- data : 전역변수와 정적변수가 저장되는 메모리 영역	
	- rod : 문자열 상수 , 리터럴


- 코드 세그먼트: 프로그램 코드가 저장되는 메모리 영역


## 배열과 포인터 차이 정리

### 선언 비교

| 선언               | 의미                                      |
|--------------------|-------------------------------------------|
| `int (*pary)[4]`   | `int[4]` 배열을 가리키는 **포인터**       |
| `int* pary[4]`     | `int*` 포인터 4개가 들어있는 **배열**      |

---

## 설명

### `int (*pary)[4];`

- `pary`는 포인터입니다.
- **`int`형 4개짜리 배열을 가리키는 포인터**입니다.
- 메모리 구조상, 배열 전체를 가리키고 있습니다.

#### 예제
```c
int arr[4] = {1, 2, 3, 4};
int (*pary)[4] = &arr;

// 배열 전체를 가리키므로 이렇게 사용 가능
printf("%d\n", (*pary)[0]);  // 1
printf("%d\n", (*pary)[1]);  // 2
```


---

# Day 05 - 동적 메모리 할당(예정)


날짜: 2025-03-17 
깃허브 링크: [day05 폴더 바로가기]()

---