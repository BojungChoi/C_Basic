# C_Basic
C 언어 기본 학습 리포지토리

---

# Day 01 - C 언어 기초
날짜: 2025-03-11  
깃허브 링크: [day01 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day01)

---

### 학습 주제
- C 언어의 특징
- 자료형과 변수
- 함수 개념 및 선언/정의/호출
- 형식 지정자
- 메모리 구조 (ROM, RAM, 레지스터)

---

### C 언어의 특징
- 절차지향 프로그래밍 언어
- 빠르고 효율적인 저수준(low-level) 언어
  - 메모리 주소를 직접 지정할 수 있음 (포인터 활용)
  - 하드웨어 친화적
- 포인터 기능 제공
  - 배열과 문자열 처리에 용이
  - 효율적인 데이터 구조를 구현 가능 (연결 리스트, 트리 등)

---

### 자료형

#### 기본형
| 자료형 | 크기 | 설명 |
|--------|------|------|
| `char` | 1바이트 (8비트) | 문자 |
| `int` | 4바이트 (32비트) | 정수 |
| `short` | 2바이트 (16비트) | 작은 정수 |
| `long` | 4바이트 (32비트) | 큰 정수 |
| `long long` | 8바이트 (64비트) | 더 큰 정수 |
| `float` | 4바이트 | 실수 (소수점) |
| `double` | 8바이트 | 정밀한 실수 |

#### 파생형
- 배열, 포인터, 구조체, 공용체, 열거형 등이 있음

---

### 함수
- 함수 선언: 함수 원형을 미리 선언해서 호출 순서와 무관하게 사용 가능
- 함수 정의: 함수의 실제 구현부
- 함수 호출: 정의된 함수 실행

#### 예시
```c
void function(); // 선언

void function() { // 정의
  printf("Hello\n");
}

int main() {
  function(); // 호출
  return 0;
}
```

---

### 형식 지정자

| 형식 지정자 | 설명 |
|-------------|------|
| `%d` / `%i` | 10진수 정수 출력 |
| `%x` / `%X` | 16진수 정수 출력 |
| `%o` | 8진수 정수 출력 |
| `%c` | 문자 출력 |
| `%s` | 문자열 출력 |
| `%f` | 실수 출력 (소수점 이하 6자리) |
| `%e` / `%E` | 지수 표기법 출력 |
| `%g` / `%G` | 자동 변환 (`%f` 또는 `%e`) |
| `%p` | 포인터 주소 출력 |

---

### 메모리 구조

| 메모리 | 설명 |
|--------|------|
| ROM | 읽기 전용 메모리. 프로그램이 저장되어 있음 |
| RAM | 임의 접근 메모리. 프로그램 실행 시 데이터 저장 |
| 레지스터 | CPU 내부 메모리. 계산 시 데이터 임시 저장 공간 |

#### 지역변수와 전역변수
- 지역변수: 함수가 호출될 때 생성, 종료 시 소멸
- 전역변수: 프로그램 시작 시 생성, 종료 시 소멸

---

# Day 02 - 연산자 & 제어문
날짜: 2025-03-12  
깃허브 링크: [day02 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day02)

---

### 연산자 정리

#### 산술 연산자
| 연산자 | 설명 | 예제 (`a = 10, b = 3`) | 결과 |
|--------|------|-------------------|------|
| `+` | 덧셈 | `a + b` | `13` |
| `-` | 뺄셈 | `a - b` | `7` |
| `*` | 곱셈 | `a * b` | `30` |
| `/` | 나눗셈 | `a / b` | `3` (정수 나눗셈) |
| `%` | 나머지 | `a % b` | `1` |

#### 논리 연산자
| 연산자 | 설명 | 예제 (`a = 1, b = 0`) | 결과 |
|--------|------|------------------|------|
| `&&` | AND | `a && b` | `0` |
| `∥` | OR | `a∥b` | `1` |
| `!` | NOT | `!a` | `0` |

---

### 제어문

#### 조건문
```c
if (조건) {
  실행문;
} else if (조건) {
  실행문;
} else {
  실행문;
}
```

#### 반복문
```c
for (초기식; 조건식; 증감식) {
  실행문;
}

while (조건식) {
  실행문;
}

do {
  실행문;
} while (조건식);
```

---

# Day 03 - 포인터 심화 학습

날짜: 2025-03-13  
깃허브 링크: [day03 폴더 바로가기](https://github.com/BojungChoi/C_Basic/tree/main/day03)

---

### 학습 주제
- 포인터와 배열의 관계
- `*`와 `&` 연산자의 정확한 의미와 사용법
- 포인터 주소값과 자료형에 따른 크기 차이
- `scanf_s` 사용 시 `sizeof`가 필요한 이유

---

### 포인터와 배열
- 배열 이름은 포인터 상수처럼 동작  
  예시: `int arr[5];`  
  `arr`은 `&arr[0]`과 동일한 메모리 주소를 가리킨다.

```c
int arr[3] = {10, 20, 30};
int *p = arr;

printf("%d\n", *p);        // 10
printf("%d\n", *(p + 1));  // 20
printf("%d\n", *(p + 2));  // 30
```

---

### `*`와 `&`의 정확한 의미

| 기호 | 의미 | 예제 |
|------|------|------|
| `*` | 역참조 (포인터가 가리키는 값 접근) | `*ptr = 100;` |
| `&` | 주소값 취득 | `ptr = &a;` |

```c
int a = 10;
int *ptr = &a;

printf("%p\n", ptr);  // 주소 출력
printf("%d\n", *ptr); // 값 출력
```

---

### 포인터 주소값과 자료형 크기

- 포인터는 자료형에 상관없이 주소값만 저장  
- 크기는 시스템 아키텍처 기준  
  - 32비트 시스템: 4바이트  
  - 64비트 시스템: 8바이트

```c
int *p1;
char *p2;
double *p3;

printf("%d\n", sizeof(p1)); // 8 (64비트)
printf("%d\n", sizeof(p2)); // 8
printf("%d\n", sizeof(p3)); // 8
```

#### 주의
- 역참조(`*ptr`)할 때 자료형 크기에 맞게 처리됨  
  `int *`는 4바이트, `char *`는 1바이트

---

### `scanf_s`와 `sizeof`가 필요한 이유

- `scanf_s`는 버퍼 오버플로 방지 목적  
- 문자열 입력 시 반드시 버퍼 크기 명시 필요

```c
char str[10];
scanf_s("%s", str, (unsigned)_countof(str)); // 또는 sizeof(str)
```

#### 왜 문자열만?  
- 문자열(`%s`)은 포인터만 전달 → 크기를 알 수 없음  
- 명시적으로 버퍼 크기를 넘겨줘야 안전

---

### 정리 요약
- 포인터는 주소값 저장, `*`와 `&`로 값과 주소를 다룸  
- 배열과 포인터는 유사하지만 다르며, 배열 이름은 상수 포인터  
- 포인터 크기는 시스템 기준으로 고정  
- `scanf_s`는 문자열 입력 시 추가 인자 필요 (버퍼 크기)

---

## Day 04 - 동적 메모리 할당 (작성 예정)
